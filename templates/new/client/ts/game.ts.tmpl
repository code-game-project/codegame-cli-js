/*
 * This code was generated by codegame-cli-js.
 * 
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */
{{ if .Node }}
import { createSocket, GameSocket, Verbosity } from '@code-game-project/client';
import type { EventListenerCallback, Session } from '@code-game-project/client';
import type { Events, Commands{{range .Commands}}, {{.PascalName}}Cmd{{end}}{{range .Events}}, {{.PascalName}}Event{{end}}, GameConfig } from './event_definitions';

import { Argument, Command, Option } from 'commander';

import { argv, env } from 'process';

function getURL(): string {
  if (!env.CG_GAME_URL) throw 'Environment variable `CG_GAME_URL` must be set.';
  else return env.CG_GAME_URL;
}
{{ else }}
import { createSocket, GameSocket, Verbosity } from '@code-game-project/client/dist/browser';
import type { EventListenerCallback, Session } from '@code-game-project/client/dist/browser';
import type { Events, Commands{{range .Commands}}, {{.PascalName}}Cmd{{end}}{{range .Events}}, {{.PascalName}}Event{{end}} } from './event_definitions';

function getURL(): string {
  const CG_GAME_URL = new URLSearchParams(window.location.search).get('game_url');
  if (!CG_GAME_URL) throw 'Query parameter "game_url" must be set.';
  else return CG_GAME_URL;
}
{{ end }}
export { Verbosity };
const VERBOSITY = ['silent', 'error', 'warning', 'info', 'debug'] as Verbosity[];
{{ if .Node }}
const PUBLIC_OPTION = new Option('--public', 'List the game as public.');
const PROTECTED_OPTION = new Option('--protected', 'Require an additional secret to join the game.');
const VERBOSITY_OPTION = new Option(
  '-v, --verbosity <level>',
  'Overrides the verbosity level passed into the `fromArgv` function.'
).choices(VERBOSITY);
{{ end }}
function logGameCreds(gameId: string, joinSecret?: string) {
  console.log('Game ID: ' + gameId);
  if (joinSecret) console.log('Join secret: ' + joinSecret);
}

/** Wrapper for {{ .GameName }}{{if .Version}} v{{ .Version }}{{end}}. */
export class Game {
  private socket: GameSocket<Events>;
  private spectating: boolean;

  /**
   * Wraps an instance of `GameSocket`.
   * @param socket A fully ready instance of `GameSocket`.
   * @param spectating Whether the socket is connected to a game as a spectator.
   */
  public constructor(socket: GameSocket<Commands, Events>, spectating: boolean) {
    this.socket = socket;
    this.spectating = spectating;
  }
  {{ if .Node }}
  /**
   * Creates a new `Game` based on the command line arguments.
   * @param config Game-specific configuration options.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async fromArgv(config?: GameConfig, verbosity?: Verbosity): Promise<{ game: Game, gameId?: string, joinSecret?: string; }> {
    return new Promise((resolve, _) => {
      new Command()
        .addCommand(new Command('create')
          .addArgument(new Argument('[username]'))
          .addOption(PUBLIC_OPTION)
          .addOption(PROTECTED_OPTION)
          .addOption(VERBOSITY_OPTION)
          .description('Create and join a new game.')
          .action(async (username, options) => {
            const { game, gameId, joinSecret } = await this.createAndJoin(username, options.public, options.protected, config, options.verbosity || verbosity);
            logGameCreds(gameId, joinSecret);
            resolve({ game, gameId, joinSecret });
          })
        )
        .addCommand(new Command('join')
          .addArgument(new Argument('<game_id>'))
          .addArgument(new Argument('<username>'))
          .addArgument(new Argument('[join_secret]'))
          .addOption(VERBOSITY_OPTION)
          .description('Join an existing game.')
          .action(async (gameId, username, join_secret, options) => resolve(await this.join(gameId, username, join_secret, options.verbosity || verbosity)))
        )
        .addCommand(new Command('reconnect')
          .addArgument(new Argument('<username>'))
          .addOption(VERBOSITY_OPTION)
          .description('Reconnect to a game using the saved session.')
          .action(async (username, options) => resolve(await this.reconnect(username, options.verbosity || verbosity)))
        )
        .addCommand(new Command('spectate')
          .addArgument(new Argument('[game_id]'))
          .addOption(PUBLIC_OPTION)
          .addOption(PROTECTED_OPTION)
          .addOption(VERBOSITY_OPTION)
          .description('Spectate a new or existing game.')
          .action(async (gameId, options) => {
            if (gameId) resolve(await this.spectate(gameId, options.verbosity || verbosity));
            else resolve(await this.createAndSpectate(options.public, options.protected, config, options.verbosity || verbosity));
          })
        )
        .parse(argv);
    });
  }
  {{ else }}
  /**
   * Creates a new `Game` based on the URL query.
   * 
   * @param config Game-specific configuration options.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   * @throws if the operation is invalid
   * 
   * ## Query Paramters
   * 
   * - op=`"create" | "join" | "connect" | "reconnect" | "spectate"`
   * - game_id=`string`
   * - join_secret=`string`
   * - player_id=`string`
   * - player_secret=`string`
   * - username=`string`
   * - public=`boolean`
   * - protected=`boolean`
   * - verbosity=`Verbosity`
   */
  public static async fromQuery(config?: GameConfig, verbosity?: Verbosity): Promise<{ game: Game, gameId?: string, joinSecret?: string; }> {
    const params = new URLSearchParams(window.location.search);
    let operation = params.get('op');
    let gameId = params.get('game_id');
    let joinSecret = params.get('join_secret');
    let playerId = params.get('player_id');
    let playerSecret = params.get('player_secret');
    let username = params.get('username');
    let _public = params.get('public') == 'true';
    let _protected = params.get('protected') == 'true';
    let verbosityOverride = params.get('verbosity') as any;
    if (!VERBOSITY.includes(verbosityOverride)) verbosityOverride = null;

    switch (operation) {
      case 'create':
        const { game, gameId, joinSecret } = await this.createAndJoin(username, _public, _protected, config, verbosityOverride || verbosity);
        logGameCreds(gameId, joinSecret);
        return { game, gameId, joinSecret };
      case 'join':
        if (gameId && username) return await this.join(gameId, username, joinSecret || undefined, verbosityOverride || verbosity);
        throw `"op=join" requires the "game_id" and "username" query parameters.`;
      case 'connect':
        if (gameId && playerId && playerSecret) return await this.connect(gameId, playerId, playerSecret, verbosityOverride || verbosity);
        throw `"op=connect" requires "game_id", "player_id" and "player_secret" query parameters.`;
      case 'reconnect':
        if (username) return await this.reconnect(username, verbosityOverride || verbosity);
        throw `"op=reconnect" requires the "username" query parameter.`;
      case 'spectate':
        if (gameId) return await this.spectate(gameId, verbosityOverride || verbosity);
        else return await this.createAndSpectate(_public, _protected, config, verbosityOverride || verbosity);
      default: throw '"op=" must be on of the following: "create", "join", "connect", "reconnect", "spectate".';
    }
  }
  {{ end }}
  /**
   * Creates a new game and joins it.
   * @param _public Whether the game should be listed as public.
   * @param _protected Whether the game should require an additional secret to join.
   * @param config Game-specific configuration options.
   * @param username The username to join with.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game` along with the game ID and optionally a join secret
   */
  public static async createAndJoin<Config extends object = object>(username: string, _public: boolean, _protected: boolean, config?: Config, verbosity?: Verbosity): Promise<{ game: Game, gameId: string, joinSecret?: string; }> {
    const socket = createSocket<Events>(getURL(), verbosity);
    const { gameId, joinSecret } = await socket.create(_public, _protected, config);
    await socket.join(gameId, username, joinSecret);
    return { game: new Game(socket, false), gameId, joinSecret };
  }

  /**
   * Joins an existing game.
   * @param username The username to join with.
   * @param verbosity The level of verbosity when logging.
   * @param join_secret An additional secret required to join protected games.
   * @returns an instance of `Game`
   */
  public static async join(gameId: string, username: string, join_secret?: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Events>(getURL(), verbosity);
    await socket.join(gameId, username, join_secret);
    return { game: new Game(socket, false) };
  }

  /**
   * Connects to a game and player using session credentials.
   * @param gameId The ID of the game to connect to.
   * @param playerId The ID of the player to connect to.
   * @param playerSecret The player's secret.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async connect(gameId: string, playerId: string, playerSecret: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Events>(getURL(), verbosity);
    await socket.connect(gameId, playerId, playerSecret);
    return { game: new Game(socket, false) };
  }

  /**
   * Tries to reconnect using an existing session.
   * @param username The username that was used when the session was created.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async reconnect(username: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Events>(getURL(), verbosity);
    await socket.restoreSession(username);
    return { game: new Game(socket, false) };
  }

  /**
   * Creates a new game and joins it as a spectator.
   * @param _public Whether the game should be listed as public.
   * @param _protected Whether the game should require an additional secret to join.
   * @param config Game-specific configuration options.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game` along with the game ID and optionally a join secret
   */
  public static async createAndSpectate<Config extends object = object>(_public: boolean, _protected: boolean, config?: Config, verbosity?: Verbosity): Promise<{ game: Game, gameId: string, joinSecret?: string; }> {
    const socket = createSocket<Events>(getURL(), verbosity);
    const { gameId, joinSecret } = await socket.create(_public, _protected, config);
    await socket.spectate(gameId);
    return { game: new Game(socket, true), gameId, joinSecret };
  }

  /**
   * Joins an existing game as a spectator.
   * @param gameId The ID of the game to connect to.
   * @param verbosity The level of verbosity when logging.
   * @returns an instance of `Game`
   */
  public static async spectate(gameId: string, verbosity?: Verbosity): Promise<{ game: Game; }> {
    const socket = createSocket<Events>(getURL(), verbosity);
    await socket.spectate(gameId);
    return { game: new Game(socket, true) };
  }

  /**
   * Gets the current session details.
   * @returns the session
   */
  public getSession(): Readonly<Session | undefined> {
    return this.socket.getSession();
  }

  /** Whether the socket is connected to a game as a spectator. */
  public isSpectating(): boolean {
    return this.spectating;
  }

  /**
   * Removes an event listener by ID.
   * @param id The listner's ID. 
   */
  public removeListener(id: symbol) {
    return this.socket.removeListener(id);
  }

  /**
   * Gets a username by player ID.
   * @param playerId The player ID.
   * @returns the username or null if the username is unavailable
   */
  public async getUsername(playerId: string): Promise<string | null> {
    return await this.socket.getUsername(playerId);
  }
  {{ range .Commands }}
  /**
   * Sends a `{{.Name}}` command.
   * @param data Optional options to go along with your command.
   */
  public send{{.PascalName}}(data: {{.PascalName}}Cmd['data']) {
    return this.socket.send<{{.PascalName}}Cmd>('{{.Name}}', data);
  }
  {{ end}} {{ range .Events }}
  /**
   * Registers an event listener for the `{{.Name}}` event.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public on{{.PascalName}}(callback: EventListenerCallback<{{.PascalName}}Event>) : symbol {
    return this.socket.on<{{.PascalName}}Event>('{{.Name}}', callback);
  }

  /**
   * Registers an event listener for the `{{.Name}}` event that will self-destruct after being triggered once.
   * @param callback Function that is executed when the event is received.
   * @returns the listener's ID
   */
  public on{{.PascalName}}Once(callback: EventListenerCallback<{{.PascalName}}Event>) : symbol {
    return this.socket.once<{{.PascalName}}Event>('{{.Name}}', callback);
  }
  {{ end }}
}
