/*
 * This code was generated by codegame-cli-js.
 * 
 * CHANGES TO THIS FILE MAY CAUSE INCORRECT BEHAVIOR AND WILL BE LOST IF
 * THE CODE IS REGENERATED.
 */
{{ if .Node }}
import { createSocket, GameSocket, Verbosity } from '@code-game-project/client';
import { Argument, Command, Option } from 'commander';

import { argv, env } from 'process';

function getURL() {
  if (!env.CG_GAME_URL) throw 'Environment variable `CG_GAME_URL` must be set.';
  else return env.CG_GAME_URL;
}
{{ else }}
import { createSocket, GameSocket, Verbosity } from '../node_modules/@code-game-project/client/dist/browser.js';

function getURL() {
  const CG_GAME_URL = new URLSearchParams(window.location.search).get('game_url');
  if (!CG_GAME_URL) throw 'Query parameter "game_url" must be set.';
  else return CG_GAME_URL;
}
{{ end }}
export { Verbosity };
const VERBOSITY = ['silent', 'error', 'warning', 'info', 'debug'];
{{ if .Node }}
const PUBLIC_OPTION = new Option('--public', 'List the game as public.');
const PROTECTED_OPTION = new Option('--protected', 'Require an additional secret to join the game.');
const VERBOSITY_OPTION = new Option(
  '-v, --verbosity <level>',
  'Overrides the verbosity level passed into the `fromArgv` function.'
).choices(VERBOSITY);
{{ end }}

function logGameCreds(gameId, joinSecret) {
  console.log('Game ID: ' + gameId);
  if (joinSecret) console.log('Join secret: ' + joinSecret);
}

/** Wrapper for {{.GameName}} v{{.Version}}. */
export class Game {
  /**
   * Wraps an instance of `GameSocket`.
   * @param {GameSocket} socket A fully ready instance of `GameSocket`.
   * @param {boolean} spectating Whether the socket is connected to a game as a spectator.
   */
  constructor(socket, spectating) {
    this.socket = socket;
    this.spectating = spectating;
  }
  {{ if .Node }}
  /**
   * Creates a new `Game` based on the command line arguments.
   * @param {Config} config Game-specific configuration options.
   * @param {Verbosity} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game, gameId?: string, joinSecret?: string; }>} an instance of `Game`
   */
  static async fromArgv(config, verbosity) {
    return new Promise((resolve, _) => {
      new Command()
        .addCommand(new Command('create')
          .addArgument(new Argument('<username>'))
          .addOption(PUBLIC_OPTION)
          .addOption(PROTECTED_OPTION)
          .addOption(VERBOSITY_OPTION)
          .description('Create and join a new game.')
          .action(async (username, options) => {
            const { game, gameId, joinSecret } = await this.createAndJoin(username, options.public, options.protected, config, options.verbosity || verbosity);
            logGameCreds(gameId, joinSecret);
            resolve({ game, gameId, joinSecret });
          })
        )
        .addCommand(new Command('join')
          .addArgument(new Argument('<game_id>'))
          .addArgument(new Argument('<username>'))
          .addArgument(new Argument('[join_secret]'))
          .addOption(VERBOSITY_OPTION)
          .description('Join an existing game.')
          .action(async (gameId, username, join_secret, options) => resolve(await this.join(gameId, username, join_secret, options.verbosity || verbosity)))
        )
        .addCommand(new Command('reconnect')
          .addArgument(new Argument('<username>'))
          .addOption(VERBOSITY_OPTION)
          .description('Reconnect to a game using the saved session.')
          .action(async (username, options) => resolve(await this.reconnect(username, options.verbosity || verbosity)))
        )
        .addCommand(new Command('spectate')
          .addArgument(new Argument('[game_id]'))
          .addOption(PUBLIC_OPTION)
          .addOption(PROTECTED_OPTION)
          .addOption(VERBOSITY_OPTION)
          .description('Spectate a new or existing game.')
          .action(async (gameId, options) => {
            if (gameId) resolve(await this.spectate(gameId, options.verbosity || verbosity));
            else {
              const { game, gameId, joinSecret } = await this.createAndSpectate(options.public, options.protected, config, options.verbosity || verbosity);
              logGameCreds(gameId, joinSecret);
              resolve({ game, gameId, joinSecret });
            }
          })
        )
        .parse(argv);
    });
  }
  {{else}}
  /**
   * Creates a new `Game` based on the URL query.
   * @param {Config} config Game-specific configuration options.
   * @param {Verbosity} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game, gameId?: string, joinSecret?: string; }>} an instance of `Game`
   * @throws if the operation is invalid
   * 
   * ## Query Paramters
   * 
   * - op=`"create"Â | "join" | "connect" | "reconnect" | "spectate"`
   * - game_id=`string`
   * - join_secret=`string`
   * - player_id=`string`
   * - player_secret=`string`
   * - username=`string`
   * - public=`boolean`
   * - protected=`boolean`
   * - verbosity=`Verbosity`
   */
  static async fromQuery(config, verbosity) {
    const params = new URLSearchParams(window.location.search);
    let operation = params.get('op');
    let gameId = params.get('game_id');
    let joinSecret = params.get('join_secret');
    let playerId = params.get('player_id');
    let playerSecret = params.get('player_secret');
    let username = params.get('username');
    let _public = params.get('public') == 'true';
    let _protected = params.get('protected') == 'true';
    let verbosityOverride = params.get('verbosity');
    if (!VERBOSITY.includes(verbosityOverride)) verbosityOverride = null;

    switch (operation) {
      case 'create':
        if (username) {
          const { game, gameId, joinSecret } = await this.createAndJoin(username, _public, _protected, config, verbosityOverride || verbosity);
          logGameCreds(gameId, joinSecret);
          return { game, gameId, joinSecret };
        }
        throw `"op=create" requires the "username" query parameter.`;
      case 'join':
        if (gameId && username) return await this.join(gameId, username, joinSecret || undefined, verbosityOverride || verbosity);
        throw `"op=join" requires the "game_id" and "username" query parameters.`;
      case 'connect':
        if (gameId && playerId && playerSecret) return await this.connect(gameId, playerId, playerSecret, verbosityOverride || verbosity);
        throw `"op=connect" requires "game_id", "player_id" and "player_secret" query parameters.`;
      case 'reconnect':
        if (username) return await this.reconnect(username, verbosityOverride || verbosity);
        throw `"op=reconnect" requires the "username" query parameter.`;
      case 'spectate':
        if (gameId) return await this.spectate(gameId, verbosityOverride || verbosity);
        else {
          const { game, gameId, joinSecret } = await this.createAndSpectate(_public, _protected, config, verbosityOverride || verbosity);
          logGameCreds(gameId, joinSecret);
          return { game, gameId, joinSecret };
        }
      default: throw '"op=" must be on of the following: "create", "join", "connect", "reconnect", "spectate".';
    }
  }
  {{ end }}

  /**
   * Creates a new game and joins it.
   * @param {boolean} _public Whether the game should be listed as public.
   * @param {boolean} _protected Whether the game should require an additional secret to join.
   * @param {Config} config Game-specific configuration options.
   * @param {string} username The username to join with.
   * @param {Verbosity} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game, gameId: string, joinSecret?: string; }>} an instance of `Game` along with the game ID and optionally a join secret
   */
  static async createAndJoin(username, _public, _protected, config, verbosity) {
    const socket = createSocket(getURL(), verbosity);
    const { gameId, joinSecret } = await socket.create(_public, _protected, config);
    await socket.join(gameId, username, joinSecret);
    return { game: new Game(socket, false), gameId, joinSecret };
  }

  /**
   * Joins an existing game.
   * @param {string} username The username to join with.
   * @param {Verbosity} verbosity The level of verbosity when logging.
   * @param {string} join_secret An additional secret required to join protected games.
   * @returns {Promise<{ game: Game; }>} an instance of `Game`
   */
  static async join(gameId, username, join_secret, verbosity) {
    const socket = createSocket(getURL(), verbosity);
    await socket.join(gameId, username, join_secret);
    return { game: new Game(socket, false) };
  }

  /**
   * Connects to a game and player using session credentials.
   * @param {string} gameId The ID of the game to connect to.
   * @param {string} playerId The ID of the player to connect to.
   * @param {string} playerSecret The player's secret.
   * @param {Verbosity} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game; }>} an instance of `Game`
   */
  static async connect(gameId, playerId, playerSecret, verbosity) {
    const socket = createSocket(getURL(), verbosity);
    await socket.connect(gameId, playerId, playerSecret);
    return { game: new Game(socket, false) };
  }

  /**
   * Tries to reconnect using an existing session.
   * @param {string} username The username that was used when the session was created.
   * @param {string} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game; }>} an instance of `Game`
   */
  static async reconnect(username, verbosity) {
    const socket = createSocket(getURL(), verbosity);
    await socket.restoreSession(username);
    return { game: new Game(socket, false) };
  }

  /**
   * Creates a new game and joins it as a spectator.
   * @param {boolean} _public Whether the game should be listed as public.
   * @param {boolean} _protected Whether the game should require an additional secret to join.
   * @param {Config} config Game-specific configuration options.
   * @param {Verbosity=} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game, gameId: string, joinSecret?: string; }>} an instance of `Game` along with the game ID and optionally a join secret
   */
  static async createAndSpectate(_public, _protected, config, verbosity) {
    const socket = createSocket(getURL(), verbosity);
    const { gameId, joinSecret } = await socket.create(_public, _protected, config);
    await socket.spectate(gameId);
    return { game: new Game(socket, true), gameId, joinSecret };
  }

  /**
   * Joins an existing game as a spectator.
   * @param {string} gameId The ID of the game to connect to.
   * @param {Verbosity=} verbosity The level of verbosity when logging.
   * @returns {Promise<{ game: Game; }>} an instance of `Game`
   */
  static async spectate(gameId, verbosity) {
    const socket = createSocket(getURL(), verbosity);
    await socket.spectate(gameId);
    return { game: new Game(socket, true) };
  }

  /**
   * Gets the current session details.
   * @returns {Readonly<Session | undefined>} the session
   */
  getSession() {
    return this.socket.getSession();
  }

  /** 
   * Whether the socket is connected to a game as a spectator.
   * @returns {boolean}
   */
  isSpectating() {
    return this.spectating;
  }

  /**
   * Removes an event listener by ID.
   * @param {symbol} id The listner's ID. 
   */
  removeListener(id) {
    return this.socket.removeListener(id);
  }

  /**
   * Gets a username by player ID.
   * @param {string} playerId The player ID.
   * @returns {Promise<string | null>} the username or null if the username is unavailable
   */
  async getUsername(playerId) {
    return await this.socket.getUsername(playerId);
  }
  {{ range .Commands }}
  /**
   * Sends a `{{.Name}}` command.
   * @param {object} data Optional options to go along with your command.
   */
  send{{.PascalName}}(data) {
    return this.socket.send('{{.Name}}', data);
  }
  {{ end}} {{ range .Events }}
  /**
   * Registers an event listener for the `{{.Name}}` event.
   * @param {(data: object) => void} callback Function that is executed when the event is received.
   * @returns {symbol} the listener's ID
   */
  on{{.PascalName}}(callback) {
    return this.socket.on('{{.Name}}', callback);
  }

  /**
   * Registers an event listener for the `{{.Name}}` event that will self-destruct after being triggered once.
   * @param {(data: object) => void} callback Function that is executed when the event is received.
   * @returns {symbol} the listener's ID
   */
  on{{.PascalName}}Once(callback) {
    return this.socket.once('{{.Name}}', callback);
  }
  {{ end }}
}
